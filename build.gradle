import gg.jte.ContentType
import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

plugins {
    id 'groovy'
    id 'java-library'
    id 'java-test-fixtures'
    id 'maven-publish'
    id "gg.jte.gradle" version "2.0.3"
    id 'com.github.johnrengelman.shadow' version '7.1.2'
}

group = 'net.gradleutil'
version = '1.1.15'

sourceCompatibility = 1.8
targetCompatibility = 1.8

repositories {
    mavenLocal()
    mavenCentral()
    maven { url "https://jitpack.io" }
}


dependencies {
    implementation 'org.codehaus.groovy:groovy-all:3.0.12'
    implementation 'gg.jte:jte:2.1.2'
    implementation 'gg.jte:jte-runtime:2.1.2'
    implementation project(":template")
    implementation 'net.gradleutil:conf:1.1.15'

    testFixturesApi('org.spockframework:spock-core:2.1-groovy-3.0')
    testFixturesImplementation('org.junit.jupiter:junit-jupiter-api')
}

tasks.withType(Test).configureEach {
    useJUnitPlatform()
}

// -> JTE
jte {
    generate()
    setPackageName('net.gradleutil.conf.jte')
    setContentType(ContentType.Plain)
}
compileJava.enabled = false
jar.dependsOn precompileJte
sourceSets.main.groovy.srcDirs += ['src/main/java', generateJte.targetDirectory]
// <- JTE

jar {
    archiveClassifier.set('core')
}

shadowJar {
    mergeServiceFiles()
    mergeGroovyExtensionModules()
    includeEmptyDirs false
    minimize {
        exclude(dependency('gg.jte:.*:.*'))
        exclude(dependency('net.gradleutil:conf.*:.*'))
    }
    archiveClassifier.set('')
    exclude 'META-INF/resources/'
    exclude 'META-INF/versions/'
    exclude 'META-INF/native/'
    exclude 'META-INF/maven/'
    exclude 'META-INF/LICENSE'
    exclude 'LICENSE.txt'
    dependencies {
        exclude(dependency('org.codehaus.groovy:.*'))
        exclude(dependency('org.spockframework:.*'))
        exclude(dependency('org.junit.jupiter:.*'))
        exclude(dependency('org.junit.platform:.*'))
        exclude(dependency('org.junit:.*'))
        exclude(dependency('junit:.*'))
        exclude(dependency('org.testng:.*'))
        exclude(dependency('org.apache.ant:.*'))
        exclude(dependency('org.opentest4j:.*'))
    }
    doLast {
        def jarFile = outputs.files.first() as File
        def formatStr = "%,10.2f"
        logger.lifecycle("Shadow jar:" + jarFile + "${String.format(formatStr, jarFile.length() / 1024)} Mb")
    }
}


task deleteGeneratedTestData(type: Delete) {
    def tempDir = sourceSets.getByName('test').allSource.files.
            findAll { it.path.contains('/temp/') }
    delete tempDir
    outputs.upToDateWhen { !tempDir }
}
tasks.withType(AbstractCompile)*.dependsOn(deleteGeneratedTestData)

java {
    withJavadocJar()
    withSourcesJar()
}

sourcesJar.doFirst{
    delete generateJte.targetDirectory
}

publishing {
    publications {
        shadow(MavenPublication) { publication ->
            project.shadow.component(publication)
            artifact sourcesJar
            artifact javadocJar
            artifact testFixturesJar
        }
    }
}

allprojects {
    plugins.withType(BasePlugin) {
        project.afterEvaluate {
            def deleteTasks = tasks.withType(Delete) + project.tasks.findByPath('clean')
            def otherTasks = tasks - deleteTasks
            otherTasks*.mustRunAfter deleteTasks
        }
    }
}

tasks.withType(AbstractPublishToMaven) { publishTask ->
    doLast {
        if (publishTask instanceof PublishToMavenRepository) {
            logger.lifecycle("Published ${project.group}.${project.name}:${version} to ${publishTask.repository.url}")
        } else if (publishTask instanceof PublishToMavenLocal) {
            String repoPath = repositories.mavenLocal().url.toURL().getFile()
            publication.with { p ->
                def sb = new StringBuilder()
                p.artifacts.each {
                    String artifactPath = p.groupId.replace(".", "/") + "/" + p.artifactId + "/" + p.version + "/" + p.artifactId + "-" + p.version
                    sb.append('\n  ' + repoPath).append(artifactPath)
                            .append(it.classifier ? '-' + it.classifier : '').append('.' + it.extension)
                }
                logger.lifecycle("Published ${p.groupId}:${p.artifactId}:${p.version}${sb.toString()}")
            }
        } else {
            logger.lifecycle("Published ${project.group}:${project.name}:${version}")
        }
    }
}

tasks.withType(Test) {
    testLogging {
        // set options for log level LIFECYCLE
        events TestLogEvent.FAILED,
                TestLogEvent.PASSED,
                TestLogEvent.SKIPPED,
                TestLogEvent.STANDARD_OUT
        exceptionFormat TestExceptionFormat.FULL
        showExceptions true
        showCauses true
        showStackTraces true

        // set options for log level DEBUG and INFO
        debug {
            events TestLogEvent.STARTED,
                    TestLogEvent.FAILED,
                    TestLogEvent.PASSED,
                    TestLogEvent.SKIPPED,
                    TestLogEvent.STANDARD_ERROR,
                    TestLogEvent.STANDARD_OUT
            exceptionFormat TestExceptionFormat.FULL
        }
        info.events = debug.events
        info.exceptionFormat = debug.exceptionFormat

        afterSuite { desc, result ->
            if (!desc.parent) {
                // will match the outermost suite
                def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} passed, ${result.failedTestCount} failed, ${result.skippedTestCount} skipped)"
                def startItem = '|  ', endItem = '  |'
                def repeatLength = startItem.length() + output.length() + endItem.length()
                println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
            }
        }
    }
}
