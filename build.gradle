import gg.jte.ContentType
import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

plugins {
    id 'groovy'
    id 'java-library'
    id 'java-test-fixtures'
    id 'maven-publish'
    id "gg.jte.gradle" version "2.3.2"
    id 'com.github.johnrengelman.shadow' version '7.1.2'
    id 'net.researchgate.release' version '3.0.2'
}

group = 'net.gradleutil'

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(11))
    }
}

tasks.compileJava {
    options.release.set(8)
}

release {
    versionPropertyFile = "${projectDir}/VERSION"
    pushReleaseVersionBranch = 'master'
    preTagCommitMessage = 'pre tag commit: '
    tagCommitMessage = 'creating tag: '
    newVersionCommitMessage = 'new version commit: '
    git {
        requireBranch.set('master')
        pushToRemote.set('origin')
        pushToBranchPrefix.set('')
        commitVersionFileOnly.set(false)
        signTag.set(true)
    }
}

repositories {
    mavenLocal()
    mavenCentral()
    maven { url "https://jitpack.io" }
}

dependencies {
    implementation 'org.codehaus.groovy:groovy:3.0.12'
    implementation 'gg.jte:jte:2.3.2'
    implementation 'gg.jte:jte-runtime:2.3.2'
    implementation 'info.picocli:picocli-groovy:4.7.5'

    if(rootProject.name == "net.gradleutil") {
        implementation project(":conf-gen:template")
        //api project(":conf")
    } else {
        implementation project(":template")
    }
    api 'net.gradleutil:conf:1.3.1'
    
    testFixturesApi('org.spockframework:spock-core:2.1-groovy-3.0')
    testFixturesImplementation('org.junit.jupiter:junit-jupiter-api')
}

tasks.withType(Test).configureEach {
    useJUnitPlatform()
}

// -> JTE
jte {
    generate()
    setPackageName('net.gradleutil.conf.jte')
    setContentType(ContentType.Plain)
}
compileJava.enabled = false
jar.dependsOn precompileJte
sourceSets.main.groovy.srcDirs += ['src/main/java', generateJte.targetDirectory]
// <- JTE

jar {
    archiveClassifier.set('core')
}

shadowJar {
    mergeServiceFiles()
    mergeGroovyExtensionModules()
    includeEmptyDirs false
    minimize {
        exclude(dependency('gg.jte:.*:.*'))
        exclude(dependency('net.gradleutil:conf.*:.*'))
    }
    archiveClassifier.set('')
    exclude 'META-INF/resources/'
    exclude 'META-INF/versions/'
    exclude 'META-INF/native/'
    exclude 'META-INF/maven/'
    exclude 'META-INF/LICENSE'
    exclude 'LICENSE.txt'
    dependencies {
        exclude(dependency('org.codehaus.groovy:.*'))
        exclude(dependency('org.spockframework:.*'))
        exclude(dependency('org.junit.jupiter:.*'))
        exclude(dependency('org.junit.platform:.*'))
        exclude(dependency('org.junit:.*'))
        exclude(dependency('junit:.*'))
        exclude(dependency('org.testng:.*'))
        exclude(dependency('org.apache.ant:.*'))
        exclude(dependency('org.opentest4j:.*'))
    }
}


task deleteGeneratedTestData(type: Delete) {
    def tempDir = sourceSets.getByName('test').allSource.files.
            findAll { it.path.contains('/temp/') }
    delete tempDir
    outputs.upToDateWhen { !tempDir }
}
tasks.withType(AbstractCompile)*.dependsOn(deleteGeneratedTestData)
tasks.named('clean').configure {it.dependsOn(deleteGeneratedTestData) }

java {
    withJavadocJar()
    withSourcesJar()
}

sourcesJar{
    dependsOn(":generateJte")
    doFirst{
        delete generateJte.targetDirectory
    }
}

publishing {
    publications {
        shadow(MavenPublication) { publication ->
            project.shadow.component(publication)
            artifact sourcesJar
            artifact javadocJar
            artifact testFixturesJar
        }
    }
}

allprojects {
    plugins.withType(BasePlugin) {
        project.afterEvaluate {
            def deleteTasks = tasks.withType(Delete) + project.tasks.findByPath('clean')
            def otherTasks = tasks - deleteTasks
            otherTasks*.mustRunAfter deleteTasks
        }
    }
}


tasks.withType(Test) {
    testLogging {
        // set options for log level LIFECYCLE
        events TestLogEvent.FAILED,
                TestLogEvent.PASSED,
                TestLogEvent.SKIPPED,
                TestLogEvent.STANDARD_OUT
        exceptionFormat TestExceptionFormat.FULL
        showExceptions true
        showCauses true
        showStackTraces true

        // set options for log level DEBUG and INFO
        debug {
            events TestLogEvent.STARTED,
                    TestLogEvent.FAILED,
                    TestLogEvent.PASSED,
                    TestLogEvent.SKIPPED,
                    TestLogEvent.STANDARD_ERROR,
                    TestLogEvent.STANDARD_OUT
            exceptionFormat TestExceptionFormat.FULL
        }
        info.events = debug.events
        info.exceptionFormat = debug.exceptionFormat

        afterSuite { desc, result ->
            if (!desc.parent) {
                // will match the outermost suite
                def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} passed, ${result.failedTestCount} failed, ${result.skippedTestCount} skipped)"
                def startItem = '|  ', endItem = '  |'
                def repeatLength = startItem.length() + output.length() + endItem.length()
                println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
            }
        }
    }
}
